{"version":3,"file":"search-CEwqX6Pz.js","sources":["../node_modules/minisearch/dist/es/index.js","../src/search.ts"],"sourcesContent":["/** @ignore */\nconst ENTRIES = 'ENTRIES';\n/** @ignore */\nconst KEYS = 'KEYS';\n/** @ignore */\nconst VALUES = 'VALUES';\n/** @ignore */\nconst LEAF = '';\n/**\n * @private\n */\nclass TreeIterator {\n    constructor(set, type) {\n        const node = set._tree;\n        const keys = Array.from(node.keys());\n        this.set = set;\n        this._type = type;\n        this._path = keys.length > 0 ? [{ node, keys }] : [];\n    }\n    next() {\n        const value = this.dive();\n        this.backtrack();\n        return value;\n    }\n    dive() {\n        if (this._path.length === 0) {\n            return { done: true, value: undefined };\n        }\n        const { node, keys } = last$1(this._path);\n        if (last$1(keys) === LEAF) {\n            return { done: false, value: this.result() };\n        }\n        const child = node.get(last$1(keys));\n        this._path.push({ node: child, keys: Array.from(child.keys()) });\n        return this.dive();\n    }\n    backtrack() {\n        if (this._path.length === 0) {\n            return;\n        }\n        const keys = last$1(this._path).keys;\n        keys.pop();\n        if (keys.length > 0) {\n            return;\n        }\n        this._path.pop();\n        this.backtrack();\n    }\n    key() {\n        return this.set._prefix + this._path\n            .map(({ keys }) => last$1(keys))\n            .filter(key => key !== LEAF)\n            .join('');\n    }\n    value() {\n        return last$1(this._path).node.get(LEAF);\n    }\n    result() {\n        switch (this._type) {\n            case VALUES: return this.value();\n            case KEYS: return this.key();\n            default: return [this.key(), this.value()];\n        }\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nconst last$1 = (array) => {\n    return array[array.length - 1];\n};\n\n/* eslint-disable no-labels */\n/**\n * @ignore\n */\nconst fuzzySearch = (node, query, maxDistance) => {\n    const results = new Map();\n    if (query === undefined)\n        return results;\n    // Number of columns in the Levenshtein matrix.\n    const n = query.length + 1;\n    // Matching terms can never be longer than N + maxDistance.\n    const m = n + maxDistance;\n    // Fill first matrix row and column with numbers: 0 1 2 3 ...\n    const matrix = new Uint8Array(m * n).fill(maxDistance + 1);\n    for (let j = 0; j < n; ++j)\n        matrix[j] = j;\n    for (let i = 1; i < m; ++i)\n        matrix[i * n] = i;\n    recurse(node, query, maxDistance, results, matrix, 1, n, '');\n    return results;\n};\n// Modified version of http://stevehanov.ca/blog/?id=114\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\nconst recurse = (node, query, maxDistance, results, matrix, m, n, prefix) => {\n    const offset = m * n;\n    key: for (const key of node.keys()) {\n        if (key === LEAF) {\n            // We've reached a leaf node. Check if the edit distance acceptable and\n            // store the result if it is.\n            const distance = matrix[offset - 1];\n            if (distance <= maxDistance) {\n                results.set(prefix, [node.get(key), distance]);\n            }\n        }\n        else {\n            // Iterate over all characters in the key. Update the Levenshtein matrix\n            // and check if the minimum distance in the last row is still within the\n            // maximum edit distance. If it is, we can recurse over all child nodes.\n            let i = m;\n            for (let pos = 0; pos < key.length; ++pos, ++i) {\n                const char = key[pos];\n                const thisRowOffset = n * i;\n                const prevRowOffset = thisRowOffset - n;\n                // Set the first column based on the previous row, and initialize the\n                // minimum distance in the current row.\n                let minDistance = matrix[thisRowOffset];\n                const jmin = Math.max(0, i - maxDistance - 1);\n                const jmax = Math.min(n - 1, i + maxDistance);\n                // Iterate over remaining columns (characters in the query).\n                for (let j = jmin; j < jmax; ++j) {\n                    const different = char !== query[j];\n                    // It might make sense to only read the matrix positions used for\n                    // deletion/insertion if the characters are different. But we want to\n                    // avoid conditional reads for performance reasons.\n                    const rpl = matrix[prevRowOffset + j] + +different;\n                    const del = matrix[prevRowOffset + j + 1] + 1;\n                    const ins = matrix[thisRowOffset + j] + 1;\n                    const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);\n                    if (dist < minDistance)\n                        minDistance = dist;\n                }\n                // Because distance will never decrease, we can stop. There will be no\n                // matching child nodes.\n                if (minDistance > maxDistance) {\n                    continue key;\n                }\n            }\n            recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);\n        }\n    }\n};\n\n/* eslint-disable no-labels */\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nclass SearchableMap {\n    /**\n     * The constructor is normally called without arguments, creating an empty\n     * map. In order to create a {@link SearchableMap} from an iterable or from an\n     * object, check {@link SearchableMap.from} and {@link\n     * SearchableMap.fromObject}.\n     *\n     * The constructor arguments are for internal use, when creating derived\n     * mutable views of a map at a prefix.\n     */\n    constructor(tree = new Map(), prefix = '') {\n        this._size = undefined;\n        this._tree = tree;\n        this._prefix = prefix;\n    }\n    /**\n     * Creates and returns a mutable view of this {@link SearchableMap},\n     * containing only entries that share the given prefix.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set(\"unicorn\", 1)\n     * map.set(\"universe\", 2)\n     * map.set(\"university\", 3)\n     * map.set(\"unique\", 4)\n     * map.set(\"hello\", 5)\n     *\n     * let uni = map.atPrefix(\"uni\")\n     * uni.get(\"unique\") // => 4\n     * uni.get(\"unicorn\") // => 1\n     * uni.get(\"hello\") // => undefined\n     *\n     * let univer = map.atPrefix(\"univer\")\n     * univer.get(\"unique\") // => undefined\n     * univer.get(\"universe\") // => 2\n     * univer.get(\"university\") // => 3\n     * ```\n     *\n     * @param prefix  The prefix\n     * @return A {@link SearchableMap} representing a mutable view of the original\n     * Map at the given prefix\n     */\n    atPrefix(prefix) {\n        if (!prefix.startsWith(this._prefix)) {\n            throw new Error('Mismatched prefix');\n        }\n        const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length));\n        if (node === undefined) {\n            const [parentNode, key] = last(path);\n            for (const k of parentNode.keys()) {\n                if (k !== LEAF && k.startsWith(key)) {\n                    const node = new Map();\n                    node.set(k.slice(key.length), parentNode.get(k));\n                    return new SearchableMap(node, prefix);\n                }\n            }\n        }\n        return new SearchableMap(node, prefix);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n     */\n    clear() {\n        this._size = undefined;\n        this._tree.clear();\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n     * @param key  Key to delete\n     */\n    delete(key) {\n        this._size = undefined;\n        return remove(this._tree, key);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n     * @return An iterator iterating through `[key, value]` entries.\n     */\n    entries() {\n        return new TreeIterator(this, ENTRIES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n     * @param fn  Iteration function\n     */\n    forEach(fn) {\n        for (const [key, value] of this) {\n            fn(key, value, this);\n        }\n    }\n    /**\n     * Returns a Map of all the entries that have a key within the given edit\n     * distance from the search key. The keys of the returned Map are the matching\n     * keys, while the values are two-element arrays where the first element is\n     * the value associated to the key, and the second is the edit distance of the\n     * key to the search key.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set('hello', 'world')\n     * map.set('hell', 'yeah')\n     * map.set('ciao', 'mondo')\n     *\n     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n     * map.fuzzyGet('hallo', 2)\n     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n     *\n     * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n     * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n     * // (change \"e\" to \"a\", delete \"o\")\n     * ```\n     *\n     * @param key  The search key\n     * @param maxEditDistance  The maximum edit distance (Levenshtein)\n     * @return A Map of the matching keys to their value and edit distance\n     */\n    fuzzyGet(key, maxEditDistance) {\n        return fuzzySearch(this._tree, key, maxEditDistance);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n     * @param key  Key to get\n     * @return Value associated to the key, or `undefined` if the key is not\n     * found.\n     */\n    get(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined ? node.get(LEAF) : undefined;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n     * @param key  Key\n     * @return True if the key is in the map, false otherwise\n     */\n    has(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined && node.has(LEAF);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n     * @return An `Iterable` iterating through keys\n     */\n    keys() {\n        return new TreeIterator(this, KEYS);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n     * @param key  Key to set\n     * @param value  Value to associate to the key\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    set(key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, value);\n        return this;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n     */\n    get size() {\n        if (this._size) {\n            return this._size;\n        }\n        /** @ignore */\n        this._size = 0;\n        const iter = this.entries();\n        while (!iter.next().done)\n            this._size += 1;\n        return this._size;\n    }\n    /**\n     * Updates the value at the given key using the provided function. The function\n     * is called with the current value at the key, and its return value is used as\n     * the new value to be set.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * // Increment the current value by one\n     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n     * ```\n     *\n     * If the value at the given key is or will be an object, it might not require\n     * re-assignment. In that case it is better to use `fetch()`, because it is\n     * faster.\n     *\n     * @param key  The key to update\n     * @param fn  The function used to compute the new value from the current one\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    update(key, fn) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, fn(node.get(LEAF)));\n        return this;\n    }\n    /**\n     * Fetches the value of the given key. If the value does not exist, calls the\n     * given function to create a new value, which is inserted at the given key\n     * and subsequently returned.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * const map = searchableMap.fetch('somekey', () => new Map())\n     * map.set('foo', 'bar')\n     * ```\n     *\n     * @param key  The key to update\n     * @param initial  A function that creates a new value if the key does not exist\n     * @return The existing or new value at the given key\n     */\n    fetch(key, initial) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        let value = node.get(LEAF);\n        if (value === undefined) {\n            node.set(LEAF, value = initial());\n        }\n        return value;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n     * @return An `Iterable` iterating through values.\n     */\n    values() {\n        return new TreeIterator(this, VALUES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Creates a {@link SearchableMap} from an `Iterable` of entries\n     *\n     * @param entries  Entries to be inserted in the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static from(entries) {\n        const tree = new SearchableMap();\n        for (const [key, value] of entries) {\n            tree.set(key, value);\n        }\n        return tree;\n    }\n    /**\n     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n     *\n     * @param object  Object of entries for the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static fromObject(object) {\n        return SearchableMap.from(Object.entries(object));\n    }\n}\nconst trackDown = (tree, key, path = []) => {\n    if (key.length === 0 || tree == null) {\n        return [tree, path];\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            path.push([tree, k]); // performance: update in place\n            return trackDown(tree.get(k), key.slice(k.length), path);\n        }\n    }\n    path.push([tree, key]); // performance: update in place\n    return trackDown(undefined, '', path);\n};\nconst lookup = (tree, key) => {\n    if (key.length === 0 || tree == null) {\n        return tree;\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            return lookup(tree.get(k), key.slice(k.length));\n        }\n    }\n};\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = (node, key) => {\n    const keyLength = key.length;\n    outer: for (let pos = 0; node && pos < keyLength;) {\n        for (const k of node.keys()) {\n            // Check whether this key is a candidate: the first characters must match.\n            if (k !== LEAF && key[pos] === k[0]) {\n                const len = Math.min(keyLength - pos, k.length);\n                // Advance offset to the point where key and k no longer match.\n                let offset = 1;\n                while (offset < len && key[pos + offset] === k[offset])\n                    ++offset;\n                const child = node.get(k);\n                if (offset === k.length) {\n                    // The existing key is shorter than the key we need to create.\n                    node = child;\n                }\n                else {\n                    // Partial match: we need to insert an intermediate node to contain\n                    // both the existing subtree and the new node.\n                    const intermediate = new Map();\n                    intermediate.set(k.slice(offset), child);\n                    node.set(key.slice(pos, pos + offset), intermediate);\n                    node.delete(k);\n                    node = intermediate;\n                }\n                pos += offset;\n                continue outer;\n            }\n        }\n        // Create a final child node to contain the final suffix of the key.\n        const child = new Map();\n        node.set(key.slice(pos), child);\n        return child;\n    }\n    return node;\n};\nconst remove = (tree, key) => {\n    const [node, path] = trackDown(tree, key);\n    if (node === undefined) {\n        return;\n    }\n    node.delete(LEAF);\n    if (node.size === 0) {\n        cleanup(path);\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        merge(path, key, value);\n    }\n};\nconst cleanup = (path) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, key] = last(path);\n    node.delete(key);\n    if (node.size === 0) {\n        cleanup(path.slice(0, -1));\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        if (key !== LEAF) {\n            merge(path.slice(0, -1), key, value);\n        }\n    }\n};\nconst merge = (path, key, value) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, nodeKey] = last(path);\n    node.set(nodeKey + key, value);\n    node.delete(nodeKey);\n};\nconst last = (array) => {\n    return array[array.length - 1];\n};\n\nconst OR = 'or';\nconst AND = 'and';\nconst AND_NOT = 'and_not';\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nclass MiniSearch {\n    /**\n     * @param options  Configuration options\n     *\n     * ### Examples:\n     *\n     * ```javascript\n     * // Create a search engine that indexes the 'title' and 'text' fields of your\n     * // documents:\n     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * ```\n     *\n     * ### ID Field:\n     *\n     * ```javascript\n     * // Your documents are assumed to include a unique 'id' field, but if you want\n     * // to use a different field for document identification, you can set the\n     * // 'idField' option:\n     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n     * ```\n     *\n     * ### Options and defaults:\n     *\n     * ```javascript\n     * // The full set of options (here with their default value) is:\n     * const miniSearch = new MiniSearch({\n     *   // idField: field that uniquely identifies a document\n     *   idField: 'id',\n     *\n     *   // extractField: function used to get the value of a field in a document.\n     *   // By default, it assumes the document is a flat object with field names as\n     *   // property keys and field values as string property values, but custom logic\n     *   // can be implemented by setting this option to a custom extractor function.\n     *   extractField: (document, fieldName) => document[fieldName],\n     *\n     *   // tokenize: function used to split fields into individual terms. By\n     *   // default, it is also used to tokenize search queries, unless a specific\n     *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n     *   // the field name is passed as the second argument.\n     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n     *\n     *   // processTerm: function used to process each tokenized term before\n     *   // indexing. It can be used for stemming and normalization. Return a falsy\n     *   // value in order to discard a term. By default, it is also used to process\n     *   // search queries, unless a specific `processTerm` option is supplied as a\n     *   // search option. When processing a term from a indexed field, the field\n     *   // name is passed as the second argument.\n     *   processTerm: (term, _fieldName) => term.toLowerCase(),\n     *\n     *   // searchOptions: default search options, see the `search` method for\n     *   // details\n     *   searchOptions: undefined,\n     *\n     *   // fields: document fields to be indexed. Mandatory, but not set by default\n     *   fields: undefined\n     *\n     *   // storeFields: document fields to be stored and returned as part of the\n     *   // search results.\n     *   storeFields: []\n     * })\n     * ```\n     */\n    constructor(options) {\n        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {\n            throw new Error('MiniSearch: option \"fields\" must be provided');\n        }\n        const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;\n        this._options = {\n            ...defaultOptions,\n            ...options,\n            autoVacuum,\n            searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n            autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n        };\n        this._index = new SearchableMap();\n        this._documentCount = 0;\n        this._documentIds = new Map();\n        this._idToShortId = new Map();\n        // Fields are defined during initialization, don't change, are few in\n        // number, rarely need iterating over, and have string keys. Therefore in\n        // this case an object is a better candidate than a Map to store the mapping\n        // from field key to ID.\n        this._fieldIds = {};\n        this._fieldLength = new Map();\n        this._avgFieldLength = [];\n        this._nextId = 0;\n        this._storedFields = new Map();\n        this._dirtCount = 0;\n        this._currentVacuum = null;\n        this._enqueuedVacuum = null;\n        this._enqueuedVacuumConditions = defaultVacuumConditions;\n        this.addFields(this._options.fields);\n    }\n    /**\n     * Adds a document to the index\n     *\n     * @param document  The document to be indexed\n     */\n    add(document) {\n        const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        if (this._idToShortId.has(id)) {\n            throw new Error(`MiniSearch: duplicate ID ${id}`);\n        }\n        const shortDocumentId = this.addDocumentId(id);\n        this.saveStoredFields(shortDocumentId, document);\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(stringifyField(fieldValue, field), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.addTerm(fieldId, shortDocumentId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.addTerm(fieldId, shortDocumentId, processedTerm);\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the given documents to the index\n     *\n     * @param documents  An array of documents to be indexed\n     */\n    addAll(documents) {\n        for (const document of documents)\n            this.add(document);\n    }\n    /**\n     * Adds all the given documents to the index asynchronously.\n     *\n     * Returns a promise that resolves (to `undefined`) when the indexing is done.\n     * This method is useful when index many documents, to avoid blocking the main\n     * thread. The indexing is performed asynchronously and in chunks.\n     *\n     * @param documents  An array of documents to be indexed\n     * @param options  Configuration options\n     * @return A promise resolving to `undefined` when the indexing is done\n     */\n    addAllAsync(documents, options = {}) {\n        const { chunkSize = 10 } = options;\n        const acc = { chunk: [], promise: Promise.resolve() };\n        const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n            chunk.push(document);\n            if ((i + 1) % chunkSize === 0) {\n                return {\n                    chunk: [],\n                    promise: promise\n                        .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n                        .then(() => this.addAll(chunk))\n                };\n            }\n            else {\n                return { chunk, promise };\n            }\n        }, acc);\n        return promise.then(() => this.addAll(chunk));\n    }\n    /**\n     * Removes the given document from the index.\n     *\n     * The document to remove must NOT have changed between indexing and removal,\n     * otherwise the index will be corrupted.\n     *\n     * This method requires passing the full document to be removed (not just the\n     * ID), and immediately removes the document from the inverted index, allowing\n     * memory to be released. A convenient alternative is {@link\n     * MiniSearch#discard}, which needs only the document ID, and has the same\n     * visible effect, but delays cleaning up the index until the next vacuuming.\n     *\n     * @param document  The document to be removed\n     */\n    remove(document) {\n        const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`);\n        }\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(stringifyField(fieldValue, field), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.removeTerm(fieldId, shortId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.removeTerm(fieldId, shortId, processedTerm);\n                }\n            }\n        }\n        this._storedFields.delete(shortId);\n        this._documentIds.delete(shortId);\n        this._idToShortId.delete(id);\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n    }\n    /**\n     * Removes all the given documents from the index. If called with no arguments,\n     * it removes _all_ documents from the index.\n     *\n     * @param documents  The documents to be removed. If this argument is omitted,\n     * all documents are removed. Note that, for removing all documents, it is\n     * more efficient to call this method with no arguments than to pass all\n     * documents.\n     */\n    removeAll(documents) {\n        if (documents) {\n            for (const document of documents)\n                this.remove(document);\n        }\n        else if (arguments.length > 0) {\n            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');\n        }\n        else {\n            this._index = new SearchableMap();\n            this._documentCount = 0;\n            this._documentIds = new Map();\n            this._idToShortId = new Map();\n            this._fieldLength = new Map();\n            this._avgFieldLength = [];\n            this._storedFields = new Map();\n            this._nextId = 0;\n        }\n    }\n    /**\n     * Discards the document with the given ID, so it won't appear in search results\n     *\n     * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n     * document to stop appearing in searches), but a different effect on the\n     * internal data structures:\n     *\n     *   - {@link MiniSearch#remove} requires passing the full document to be\n     *   removed as argument, and removes it from the inverted index immediately.\n     *\n     *   - {@link MiniSearch#discard} instead only needs the document ID, and\n     *   works by marking the current version of the document as discarded, so it\n     *   is immediately ignored by searches. This is faster and more convenient\n     *   than {@link MiniSearch#remove}, but the index is not immediately\n     *   modified. To take care of that, vacuuming is performed after a certain\n     *   number of documents are discarded, cleaning up the index and allowing\n     *   memory to be released.\n     *\n     * After discarding a document, it is possible to re-add a new version, and\n     * only the new version will appear in searches. In other words, discarding\n     * and re-adding a document works exactly like removing and re-adding it. The\n     * {@link MiniSearch.replace} method can also be used to replace a document\n     * with a new version.\n     *\n     * #### Details about vacuuming\n     *\n     * Repetite calls to this method would leave obsolete document references in\n     * the index, invisible to searches. Two mechanisms take care of cleaning up:\n     * clean up during search, and vacuuming.\n     *\n     *   - Upon search, whenever a discarded ID is found (and ignored for the\n     *   results), references to the discarded document are removed from the\n     *   inverted index entries for the search terms. This ensures that subsequent\n     *   searches for the same terms do not need to skip these obsolete references\n     *   again.\n     *\n     *   - In addition, vacuuming is performed automatically by default (see the\n     *   `autoVacuum` field in {@link Options}) after a certain number of\n     *   documents are discarded. Vacuuming traverses all terms in the index,\n     *   cleaning up all references to discarded documents. Vacuuming can also be\n     *   triggered manually by calling {@link MiniSearch#vacuum}.\n     *\n     * @param id  The ID of the document to be discarded\n     */\n    discard(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`);\n        }\n        this._idToShortId.delete(id);\n        this._documentIds.delete(shortId);\n        this._storedFields.delete(shortId);\n        (this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n            this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength);\n        });\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n        this._dirtCount += 1;\n        this.maybeAutoVacuum();\n    }\n    maybeAutoVacuum() {\n        if (this._options.autoVacuum === false) {\n            return;\n        }\n        const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum;\n        this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });\n    }\n    /**\n     * Discards the documents with the given IDs, so they won't appear in search\n     * results\n     *\n     * It is equivalent to calling {@link MiniSearch#discard} for all the given\n     * IDs, but with the optimization of triggering at most one automatic\n     * vacuuming at the end.\n     *\n     * Note: to remove all documents from the index, it is faster and more\n     * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n     * of passing all IDs to this method.\n     */\n    discardAll(ids) {\n        const autoVacuum = this._options.autoVacuum;\n        try {\n            this._options.autoVacuum = false;\n            for (const id of ids) {\n                this.discard(id);\n            }\n        }\n        finally {\n            this._options.autoVacuum = autoVacuum;\n        }\n        this.maybeAutoVacuum();\n    }\n    /**\n     * It replaces an existing document with the given updated version\n     *\n     * It works by discarding the current version and adding the updated one, so\n     * it is functionally equivalent to calling {@link MiniSearch#discard}\n     * followed by {@link MiniSearch#add}. The ID of the updated document should\n     * be the same as the original one.\n     *\n     * Since it uses {@link MiniSearch#discard} internally, this method relies on\n     * vacuuming to clean up obsolete document references from the index, allowing\n     * memory to be released (see {@link MiniSearch#discard}).\n     *\n     * @param updatedDocument  The updated document to replace the old version\n     * with\n     */\n    replace(updatedDocument) {\n        const { idField, extractField } = this._options;\n        const id = extractField(updatedDocument, idField);\n        this.discard(id);\n        this.add(updatedDocument);\n    }\n    /**\n     * Triggers a manual vacuuming, cleaning up references to discarded documents\n     * from the inverted index\n     *\n     * Vacuuming is only useful for applications that use the {@link\n     * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n     *\n     * By default, vacuuming is performed automatically when needed (controlled by\n     * the `autoVacuum` field in {@link Options}), so there is usually no need to\n     * call this method, unless one wants to make sure to perform vacuuming at a\n     * specific moment.\n     *\n     * Vacuuming traverses all terms in the inverted index in batches, and cleans\n     * up references to discarded documents from the posting list, allowing memory\n     * to be released.\n     *\n     * The method takes an optional object as argument with the following keys:\n     *\n     *   - `batchSize`: the size of each batch (1000 by default)\n     *\n     *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n     *   default)\n     *\n     * On large indexes, vacuuming could have a non-negligible cost: batching\n     * avoids blocking the thread for long, diluting this cost so that it is not\n     * negatively affecting the application. Nonetheless, this method should only\n     * be called when necessary, and relying on automatic vacuuming is usually\n     * better.\n     *\n     * It returns a promise that resolves (to undefined) when the clean up is\n     * completed. If vacuuming is already ongoing at the time this method is\n     * called, a new one is enqueued immediately after the ongoing one, and a\n     * corresponding promise is returned. However, no more than one vacuuming is\n     * enqueued on top of the ongoing one, even if this method is called more\n     * times (enqueuing multiple ones would be useless).\n     *\n     * @param options  Configuration options for the batch size and delay. See\n     * {@link VacuumOptions}.\n     */\n    vacuum(options = {}) {\n        return this.conditionalVacuum(options);\n    }\n    conditionalVacuum(options, conditions) {\n        // If a vacuum is already ongoing, schedule another as soon as it finishes,\n        // unless there's already one enqueued. If one was already enqueued, do not\n        // enqueue another on top, but make sure that the conditions are the\n        // broadest.\n        if (this._currentVacuum) {\n            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;\n            if (this._enqueuedVacuum != null) {\n                return this._enqueuedVacuum;\n            }\n            this._enqueuedVacuum = this._currentVacuum.then(() => {\n                const conditions = this._enqueuedVacuumConditions;\n                this._enqueuedVacuumConditions = defaultVacuumConditions;\n                return this.performVacuuming(options, conditions);\n            });\n            return this._enqueuedVacuum;\n        }\n        if (this.vacuumConditionsMet(conditions) === false) {\n            return Promise.resolve();\n        }\n        this._currentVacuum = this.performVacuuming(options);\n        return this._currentVacuum;\n    }\n    async performVacuuming(options, conditions) {\n        const initialDirtCount = this._dirtCount;\n        if (this.vacuumConditionsMet(conditions)) {\n            const batchSize = options.batchSize || defaultVacuumOptions.batchSize;\n            const batchWait = options.batchWait || defaultVacuumOptions.batchWait;\n            let i = 1;\n            for (const [term, fieldsData] of this._index) {\n                for (const [fieldId, fieldIndex] of fieldsData) {\n                    for (const [shortId] of fieldIndex) {\n                        if (this._documentIds.has(shortId)) {\n                            continue;\n                        }\n                        if (fieldIndex.size <= 1) {\n                            fieldsData.delete(fieldId);\n                        }\n                        else {\n                            fieldIndex.delete(shortId);\n                        }\n                    }\n                }\n                if (this._index.get(term).size === 0) {\n                    this._index.delete(term);\n                }\n                if (i % batchSize === 0) {\n                    await new Promise((resolve) => setTimeout(resolve, batchWait));\n                }\n                i += 1;\n            }\n            this._dirtCount -= initialDirtCount;\n        }\n        // Make the next lines always async, so they execute after this function returns\n        await null;\n        this._currentVacuum = this._enqueuedVacuum;\n        this._enqueuedVacuum = null;\n    }\n    vacuumConditionsMet(conditions) {\n        if (conditions == null) {\n            return true;\n        }\n        let { minDirtCount, minDirtFactor } = conditions;\n        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;\n        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;\n        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;\n    }\n    /**\n     * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n     */\n    get isVacuuming() {\n        return this._currentVacuum != null;\n    }\n    /**\n     * The number of documents discarded since the most recent vacuuming\n     */\n    get dirtCount() {\n        return this._dirtCount;\n    }\n    /**\n     * A number between 0 and 1 giving an indication about the proportion of\n     * documents that are discarded, and can therefore be cleaned up by vacuuming.\n     * A value close to 0 means that the index is relatively clean, while a higher\n     * value means that the index is relatively dirty, and vacuuming could release\n     * memory.\n     */\n    get dirtFactor() {\n        return this._dirtCount / (1 + this._documentCount + this._dirtCount);\n    }\n    /**\n     * Returns `true` if a document with the given ID is present in the index and\n     * available for search, `false` otherwise\n     *\n     * @param id  The document ID\n     */\n    has(id) {\n        return this._idToShortId.has(id);\n    }\n    /**\n     * Returns the stored fields (as configured in the `storeFields` constructor\n     * option) for the given document ID. Returns `undefined` if the document is\n     * not present in the index.\n     *\n     * @param id  The document ID\n     */\n    getStoredFields(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            return undefined;\n        }\n        return this._storedFields.get(shortId);\n    }\n    /**\n     * Search for documents matching the given search query.\n     *\n     * The result is a list of scored document IDs matching the query, sorted by\n     * descending score, and each including data about which terms were matched and\n     * in which fields.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Search for \"zen art motorcycle\" with default options: terms have to match\n     * // exactly, and individual terms are joined with OR\n     * miniSearch.search('zen art motorcycle')\n     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n     * ```\n     *\n     * ### Restrict search to specific fields:\n     *\n     * ```javascript\n     * // Search only in the 'title' field\n     * miniSearch.search('zen', { fields: ['title'] })\n     * ```\n     *\n     * ### Field boosting:\n     *\n     * ```javascript\n     * // Boost a field\n     * miniSearch.search('zen', { boost: { title: 2 } })\n     * ```\n     *\n     * ### Prefix search:\n     *\n     * ```javascript\n     * // Search for \"moto\" with prefix search (it will match documents\n     * // containing terms that start with \"moto\" or \"neuro\")\n     * miniSearch.search('moto neuro', { prefix: true })\n     * ```\n     *\n     * ### Fuzzy search:\n     *\n     * ```javascript\n     * // Search for \"ismael\" with fuzzy search (it will match documents containing\n     * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n     * // (rounded to nearest integer)\n     * miniSearch.search('ismael', { fuzzy: 0.2 })\n     * ```\n     *\n     * ### Combining strategies:\n     *\n     * ```javascript\n     * // Mix of exact match, prefix search, and fuzzy search\n     * miniSearch.search('ismael mob', {\n     *  prefix: true,\n     *  fuzzy: 0.2\n     * })\n     * ```\n     *\n     * ### Advanced prefix and fuzzy search:\n     *\n     * ```javascript\n     * // Perform fuzzy and prefix search depending on the search term. Here\n     * // performing prefix and fuzzy search only on terms longer than 3 characters\n     * miniSearch.search('ismael mob', {\n     *  prefix: term => term.length > 3\n     *  fuzzy: term => term.length > 3 ? 0.2 : null\n     * })\n     * ```\n     *\n     * ### Combine with AND:\n     *\n     * ```javascript\n     * // Combine search terms with AND (to match only documents that contain both\n     * // \"motorcycle\" and \"art\")\n     * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n     * ```\n     *\n     * ### Combine with AND_NOT:\n     *\n     * There is also an AND_NOT combinator, that finds documents that match the\n     * first term, but do not match any of the other terms. This combinator is\n     * rarely useful with simple queries, and is meant to be used with advanced\n     * query combinations (see later for more details).\n     *\n     * ### Filtering results:\n     *\n     * ```javascript\n     * // Filter only results in the 'fiction' category (assuming that 'category'\n     * // is a stored field)\n     * miniSearch.search('motorcycle art', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Wildcard query\n     *\n     * Searching for an empty string (assuming the default tokenizer) returns no\n     * results. Sometimes though, one needs to match all documents, like in a\n     * \"wildcard\" search. This is possible by passing the special value\n     * {@link MiniSearch.wildcard} as the query:\n     *\n     * ```javascript\n     * // Return search results for all documents\n     * miniSearch.search(MiniSearch.wildcard)\n     * ```\n     *\n     * Note that search options such as `filter` and `boostDocument` are still\n     * applied, influencing which results are returned, and their order:\n     *\n     * ```javascript\n     * // Return search results for all documents in the 'fiction' category\n     * miniSearch.search(MiniSearch.wildcard, {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Advanced combination of queries:\n     *\n     * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n     * and even with different search options, by passing a query expression\n     * tree object as the first argument, instead of a string.\n     *\n     * ```javascript\n     * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n     * miniSearch.search({\n     *   combineWith: 'AND',\n     *   queries: [\n     *     'zen',\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['motorcycle', 'archery']\n     *     }\n     *   ]\n     * })\n     *\n     * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n     * // not \"tree\"\n     * miniSearch.search({\n     *   combineWith: 'AND_NOT',\n     *   queries: [\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['apple', 'pear']\n     *     },\n     *     'juice',\n     *     'tree'\n     *   ]\n     * })\n     * ```\n     *\n     * Each node in the expression tree can be either a string, or an object that\n     * supports all {@link SearchOptions} fields, plus a `queries` array field for\n     * subqueries.\n     *\n     * Note that, while this can become complicated to do by hand for complex or\n     * deeply nested queries, it provides a formalized expression tree API for\n     * external libraries that implement a parser for custom query languages.\n     *\n     * @param query  Search query\n     * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n     */\n    search(query, searchOptions = {}) {\n        const { searchOptions: globalSearchOptions } = this._options;\n        const searchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions };\n        const rawResults = this.executeQuery(query, searchOptions);\n        const results = [];\n        for (const [docId, { score, terms, match }] of rawResults) {\n            // terms are the matched query terms, which will be returned to the user\n            // as queryTerms. The quality is calculated based on them, as opposed to\n            // the matched terms in the document (which can be different due to\n            // prefix and fuzzy match)\n            const quality = terms.length || 1;\n            const result = {\n                id: this._documentIds.get(docId),\n                score: score * quality,\n                terms: Object.keys(match),\n                queryTerms: terms,\n                match\n            };\n            Object.assign(result, this._storedFields.get(docId));\n            if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n                results.push(result);\n            }\n        }\n        // If it's a wildcard query, and no document boost is applied, skip sorting\n        // the results, as all results have the same score of 1\n        if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n            return results;\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Provide suggestions for the given search query\n     *\n     * The result is a list of suggested modified search queries, derived from the\n     * given search query, each with a relevance score, sorted by descending score.\n     *\n     * By default, it uses the same options used for search, except that by\n     * default it performs prefix search on the last term of the query, and\n     * combine terms with `'AND'` (requiring all query terms to match). Custom\n     * options can be passed as a second argument. Defaults can be changed upon\n     * calling the {@link MiniSearch} constructor, by passing a\n     * `autoSuggestOptions` option.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Get suggestions for 'neuro':\n     * miniSearch.autoSuggest('neuro')\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n     * ```\n     *\n     * ### Multiple words:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar':\n     * miniSearch.autoSuggest('zen ar')\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * ### Fuzzy suggestions:\n     *\n     * ```javascript\n     * // Correct spelling mistakes using fuzzy search:\n     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n     * ```\n     *\n     * ### Filtering:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar', but only within the 'fiction' category\n     * // (assuming that 'category' is a stored field):\n     * miniSearch.autoSuggest('zen ar', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * @param queryString  Query string to be expanded into suggestions\n     * @param options  Search options. The supported options and default values\n     * are the same as for the {@link MiniSearch#search} method, except that by\n     * default prefix search is performed on the last term in the query, and terms\n     * are combined with `'AND'`.\n     * @return  A sorted array of suggestions sorted by relevance score.\n     */\n    autoSuggest(queryString, options = {}) {\n        options = { ...this._options.autoSuggestOptions, ...options };\n        const suggestions = new Map();\n        for (const { score, terms } of this.search(queryString, options)) {\n            const phrase = terms.join(' ');\n            const suggestion = suggestions.get(phrase);\n            if (suggestion != null) {\n                suggestion.score += score;\n                suggestion.count += 1;\n            }\n            else {\n                suggestions.set(phrase, { score, terms, count: 1 });\n            }\n        }\n        const results = [];\n        for (const [suggestion, { score, terms, count }] of suggestions) {\n            results.push({ suggestion, terms, score: score / count });\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Total number of documents available to search\n     */\n    get documentCount() {\n        return this._documentCount;\n    }\n    /**\n     * Number of terms in the index\n     */\n    get termCount() {\n        return this._index.size;\n    }\n    /**\n     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n     * and instantiates a MiniSearch instance. It should be given the same options\n     * originally used when serializing the index.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // If the index was serialized with:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     *\n     * const json = JSON.stringify(miniSearch)\n     * // It can later be deserialized like this:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return An instance of MiniSearch deserialized from the given JSON.\n     */\n    static loadJSON(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJS(JSON.parse(json), options);\n    }\n    /**\n     * Async equivalent of {@link MiniSearch.loadJSON}\n     *\n     * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n     * a promise, and loads the index in batches, leaving pauses between them to avoid\n     * blocking the main thread. It tends to be slower than the synchronous\n     * version, but does not block the main thread, so it can be a better choice\n     * when deserializing very large indexes.\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n     */\n    static async loadJSONAsync(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJSAsync(JSON.parse(json), options);\n    }\n    /**\n     * Returns the default value of an option. It will throw an error if no option\n     * with the given name exists.\n     *\n     * @param optionName  Name of the option\n     * @return The default value of the given option\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Get default tokenizer\n     * MiniSearch.getDefault('tokenize')\n     *\n     * // Get default term processor\n     * MiniSearch.getDefault('processTerm')\n     *\n     * // Unknown options will throw an error\n     * MiniSearch.getDefault('notExisting')\n     * // => throws 'MiniSearch: unknown option \"notExisting\"'\n     * ```\n     */\n    static getDefault(optionName) {\n        if (defaultOptions.hasOwnProperty(optionName)) {\n            return getOwnProperty(defaultOptions, optionName);\n        }\n        else {\n            throw new Error(`MiniSearch: unknown option \"${optionName}\"`);\n        }\n    }\n    /**\n     * @ignore\n     */\n    static loadJS(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = objectToNumericMap(documentIds);\n        miniSearch._fieldLength = objectToNumericMap(fieldLength);\n        miniSearch._storedFields = objectToNumericMap(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));\n            }\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static async loadJSAsync(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = await objectToNumericMapAsync(documentIds);\n        miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength);\n        miniSearch._storedFields = await objectToNumericMapAsync(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        let count = 0;\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry));\n            }\n            if (++count % 1000 === 0)\n                await wait(0);\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static instantiateMiniSearch(js, options) {\n        const { documentCount, nextId, fieldIds, averageFieldLength, dirtCount, serializationVersion } = js;\n        if (serializationVersion !== 1 && serializationVersion !== 2) {\n            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');\n        }\n        const miniSearch = new MiniSearch(options);\n        miniSearch._documentCount = documentCount;\n        miniSearch._nextId = nextId;\n        miniSearch._idToShortId = new Map();\n        miniSearch._fieldIds = fieldIds;\n        miniSearch._avgFieldLength = averageFieldLength;\n        miniSearch._dirtCount = dirtCount || 0;\n        miniSearch._index = new SearchableMap();\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    executeQuery(query, searchOptions = {}) {\n        if (query === MiniSearch.wildcard) {\n            return this.executeWildcardQuery(searchOptions);\n        }\n        if (typeof query !== 'string') {\n            const options = { ...searchOptions, ...query, queries: undefined };\n            const results = query.queries.map((subquery) => this.executeQuery(subquery, options));\n            return this.combineResults(results, options.combineWith);\n        }\n        const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options;\n        const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions };\n        const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options;\n        const terms = searchTokenize(query)\n            .flatMap((term) => searchProcessTerm(term))\n            .filter((term) => !!term);\n        const queries = terms.map(termToQuerySpec(options));\n        const results = queries.map(query => this.executeQuerySpec(query, options));\n        return this.combineResults(results, options.combineWith);\n    }\n    /**\n     * @ignore\n     */\n    executeQuerySpec(query, searchOptions) {\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        const boosts = (options.fields || this._options.fields).reduce((boosts, field) => ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {});\n        const { boostDocument, weights, maxFuzzy, bm25: bm25params } = options;\n        const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights };\n        const data = this._index.get(query.term);\n        const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params);\n        let prefixMatches;\n        let fuzzyMatches;\n        if (query.prefix) {\n            prefixMatches = this._index.atPrefix(query.term);\n        }\n        if (query.fuzzy) {\n            const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;\n            const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;\n            if (maxDistance)\n                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);\n        }\n        if (prefixMatches) {\n            for (const [term, data] of prefixMatches) {\n                const distance = term.length - query.term.length;\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Delete the term from fuzzy results (if present) if it is also a\n                // prefix result. This entry will always be scored as a prefix result.\n                fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to prefixWeight.\n                // The rate of change is much lower than that of fuzzy matches to\n                // account for the fact that prefix matches stay more relevant than\n                // fuzzy matches for longer distances.\n                const weight = prefixWeight * term.length / (term.length + 0.3 * distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        if (fuzzyMatches) {\n            for (const term of fuzzyMatches.keys()) {\n                const [data, distance] = fuzzyMatches.get(term);\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n                const weight = fuzzyWeight * term.length / (term.length + distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    executeWildcardQuery(searchOptions) {\n        const results = new Map();\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        for (const [shortId, id] of this._documentIds) {\n            const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;\n            results.set(shortId, {\n                score,\n                terms: [],\n                match: {}\n            });\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    combineResults(results, combineWith = OR) {\n        if (results.length === 0) {\n            return new Map();\n        }\n        const operator = combineWith.toLowerCase();\n        const combinator = combinators[operator];\n        if (!combinator) {\n            throw new Error(`Invalid combination operator: ${combineWith}`);\n        }\n        return results.reduce(combinator) || new Map();\n    }\n    /**\n     * Allows serialization of the index to JSON, to possibly store it and later\n     * deserialize it with {@link MiniSearch.loadJSON}.\n     *\n     * Normally one does not directly call this method, but rather call the\n     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n     * instance, and JavaScript will internally call this method. Upon\n     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n     * options used to create the original instance that was serialized.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Serialize the index:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     * const json = JSON.stringify(miniSearch)\n     *\n     * // Later, to deserialize it:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @return A plain-object serializable representation of the search index.\n     */\n    toJSON() {\n        const index = [];\n        for (const [term, fieldIndex] of this._index) {\n            const data = {};\n            for (const [fieldId, freqs] of fieldIndex) {\n                data[fieldId] = Object.fromEntries(freqs);\n            }\n            index.push([term, data]);\n        }\n        return {\n            documentCount: this._documentCount,\n            nextId: this._nextId,\n            documentIds: Object.fromEntries(this._documentIds),\n            fieldIds: this._fieldIds,\n            fieldLength: Object.fromEntries(this._fieldLength),\n            averageFieldLength: this._avgFieldLength,\n            storedFields: Object.fromEntries(this._storedFields),\n            dirtCount: this._dirtCount,\n            index,\n            serializationVersion: 2\n        };\n    }\n    /**\n     * @ignore\n     */\n    termResults(sourceTerm, derivedTerm, termWeight, termBoost, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results = new Map()) {\n        if (fieldTermData == null)\n            return results;\n        for (const field of Object.keys(fieldBoosts)) {\n            const fieldBoost = fieldBoosts[field];\n            const fieldId = this._fieldIds[field];\n            const fieldTermFreqs = fieldTermData.get(fieldId);\n            if (fieldTermFreqs == null)\n                continue;\n            let matchingFields = fieldTermFreqs.size;\n            const avgFieldLength = this._avgFieldLength[fieldId];\n            for (const docId of fieldTermFreqs.keys()) {\n                if (!this._documentIds.has(docId)) {\n                    this.removeTerm(fieldId, docId, derivedTerm);\n                    matchingFields -= 1;\n                    continue;\n                }\n                const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;\n                if (!docBoost)\n                    continue;\n                const termFreq = fieldTermFreqs.get(docId);\n                const fieldLength = this._fieldLength.get(docId)[fieldId];\n                // NOTE: The total number of fields is set to the number of documents\n                // `this._documentCount`. It could also make sense to use the number of\n                // documents where the current field is non-blank as a normalization\n                // factor. This will make a difference in scoring if the field is rarely\n                // present. This is currently not supported, and may require further\n                // analysis to see if it is a valid use case.\n                const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);\n                const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore;\n                const result = results.get(docId);\n                if (result) {\n                    result.score += weightedScore;\n                    assignUniqueTerm(result.terms, sourceTerm);\n                    const match = getOwnProperty(result.match, derivedTerm);\n                    if (match) {\n                        match.push(field);\n                    }\n                    else {\n                        result.match[derivedTerm] = [field];\n                    }\n                }\n                else {\n                    results.set(docId, {\n                        score: weightedScore,\n                        terms: [sourceTerm],\n                        match: { [derivedTerm]: [field] }\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    addTerm(fieldId, documentId, term) {\n        const indexData = this._index.fetch(term, createMap);\n        let fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null) {\n            fieldIndex = new Map();\n            fieldIndex.set(documentId, 1);\n            indexData.set(fieldId, fieldIndex);\n        }\n        else {\n            const docs = fieldIndex.get(documentId);\n            fieldIndex.set(documentId, (docs || 0) + 1);\n        }\n    }\n    /**\n     * @ignore\n     */\n    removeTerm(fieldId, documentId, term) {\n        if (!this._index.has(term)) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n            return;\n        }\n        const indexData = this._index.fetch(term, createMap);\n        const fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n        }\n        else if (fieldIndex.get(documentId) <= 1) {\n            if (fieldIndex.size <= 1) {\n                indexData.delete(fieldId);\n            }\n            else {\n                fieldIndex.delete(documentId);\n            }\n        }\n        else {\n            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);\n        }\n        if (this._index.get(term).size === 0) {\n            this._index.delete(term);\n        }\n    }\n    /**\n     * @ignore\n     */\n    warnDocumentChanged(shortDocumentId, fieldId, term) {\n        for (const fieldName of Object.keys(this._fieldIds)) {\n            if (this._fieldIds[fieldName] === fieldId) {\n                this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict');\n                return;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    addDocumentId(documentId) {\n        const shortDocumentId = this._nextId;\n        this._idToShortId.set(documentId, shortDocumentId);\n        this._documentIds.set(shortDocumentId, documentId);\n        this._documentCount += 1;\n        this._nextId += 1;\n        return shortDocumentId;\n    }\n    /**\n     * @ignore\n     */\n    addFields(fields) {\n        for (let i = 0; i < fields.length; i++) {\n            this._fieldIds[fields[i]] = i;\n        }\n    }\n    /**\n     * @ignore\n     */\n    addFieldLength(documentId, fieldId, count, length) {\n        let fieldLengths = this._fieldLength.get(documentId);\n        if (fieldLengths == null)\n            this._fieldLength.set(documentId, fieldLengths = []);\n        fieldLengths[fieldId] = length;\n        const averageFieldLength = this._avgFieldLength[fieldId] || 0;\n        const totalFieldLength = (averageFieldLength * count) + length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);\n    }\n    /**\n     * @ignore\n     */\n    removeFieldLength(documentId, fieldId, count, length) {\n        if (count === 1) {\n            this._avgFieldLength[fieldId] = 0;\n            return;\n        }\n        const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);\n    }\n    /**\n     * @ignore\n     */\n    saveStoredFields(documentId, doc) {\n        const { storeFields, extractField } = this._options;\n        if (storeFields == null || storeFields.length === 0) {\n            return;\n        }\n        let documentFields = this._storedFields.get(documentId);\n        if (documentFields == null)\n            this._storedFields.set(documentId, documentFields = {});\n        for (const fieldName of storeFields) {\n            const fieldValue = extractField(doc, fieldName);\n            if (fieldValue !== undefined)\n                documentFields[fieldName] = fieldValue;\n        }\n    }\n}\n/**\n * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n * to match all documents\n */\nMiniSearch.wildcard = Symbol('*');\nconst getOwnProperty = (object, property) => Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\nconst combinators = {\n    [OR]: (a, b) => {\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null) {\n                a.set(docId, b.get(docId));\n            }\n            else {\n                const { score, terms, match } = b.get(docId);\n                existing.score = existing.score + score;\n                existing.match = Object.assign(existing.match, match);\n                assignUniqueTerms(existing.terms, terms);\n            }\n        }\n        return a;\n    },\n    [AND]: (a, b) => {\n        const combined = new Map();\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null)\n                continue;\n            const { score, terms, match } = b.get(docId);\n            assignUniqueTerms(existing.terms, terms);\n            combined.set(docId, {\n                score: existing.score + score,\n                terms: existing.terms,\n                match: Object.assign(existing.match, match)\n            });\n        }\n        return combined;\n    },\n    [AND_NOT]: (a, b) => {\n        for (const docId of b.keys())\n            a.delete(docId);\n        return a;\n    }\n};\nconst defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };\nconst calcBM25Score = (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) => {\n    const { k, b, d } = bm25params;\n    const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));\n};\nconst termToQuerySpec = (options) => (term, i, terms) => {\n    const fuzzy = (typeof options.fuzzy === 'function')\n        ? options.fuzzy(term, i, terms)\n        : (options.fuzzy || false);\n    const prefix = (typeof options.prefix === 'function')\n        ? options.prefix(term, i, terms)\n        : (options.prefix === true);\n    const termBoost = (typeof options.boostTerm === 'function')\n        ? options.boostTerm(term, i, terms)\n        : 1;\n    return { term, fuzzy, prefix, termBoost };\n};\nconst defaultOptions = {\n    idField: 'id',\n    extractField: (document, fieldName) => document[fieldName],\n    stringifyField: (fieldValue, fieldName) => fieldValue.toString(),\n    tokenize: (text) => text.split(SPACE_OR_PUNCTUATION),\n    processTerm: (term) => term.toLowerCase(),\n    fields: undefined,\n    searchOptions: undefined,\n    storeFields: [],\n    logger: (level, message) => {\n        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')\n            console[level](message);\n    },\n    autoVacuum: true\n};\nconst defaultSearchOptions = {\n    combineWith: OR,\n    prefix: false,\n    fuzzy: false,\n    maxFuzzy: 6,\n    boost: {},\n    weights: { fuzzy: 0.45, prefix: 0.375 },\n    bm25: defaultBM25params\n};\nconst defaultAutoSuggestOptions = {\n    combineWith: AND,\n    prefix: (term, i, terms) => i === terms.length - 1\n};\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions };\nconst assignUniqueTerm = (target, term) => {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term))\n        target.push(term);\n};\nconst assignUniqueTerms = (target, source) => {\n    for (const term of source) {\n        // Avoid adding duplicate terms.\n        if (!target.includes(term))\n            target.push(term);\n    }\n};\nconst byScore = ({ score: a }, { score: b }) => b - a;\nconst createMap = () => new Map();\nconst objectToNumericMap = (object) => {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n    }\n    return map;\n};\nconst objectToNumericMapAsync = async (object) => {\n    const map = new Map();\n    let count = 0;\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n        if (++count % 1000 === 0) {\n            await wait(0);\n        }\n    }\n    return map;\n};\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u;\n\nexport { MiniSearch as default };\n//# sourceMappingURL=index.js.map\n","/**\n * Search Component\n * Fuzzy search using MiniSearch\n */\n\nimport MiniSearch from 'minisearch';\nimport { resolveWithBase } from './site-context';\n\ninterface SearchDocument {\n  id: string;\n  url: string;\n  title: string;\n  section_title: string;\n  content: string;\n  snippet: string;\n  tags: string[];\n  type: 'essay' | 'thought' | 'doc';\n}\n\nclass SearchManager {\n  private searchIndex: MiniSearch<SearchDocument> | null = null;\n  private documents: SearchDocument[] = [];\n  private searchModal: HTMLElement | null = null;\n  private searchInput: HTMLInputElement | null = null;\n  private searchResults: HTMLDivElement | null = null;\n  private selectedIndex: number = -1;\n  private searchGraphCleanup: (() => void) | null = null;\n  private indexLoadPromise: Promise<void> | null = null;\n  private indexReady = false;\n  private initialized = false;\n\n  async init(): Promise<void> {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    // Set up UI first (must happen after DOM is ready)\n    this.setupUI();\n  }\n\n  private setupUI(): void {\n    this.searchModal = document.getElementById('search-modal');\n    this.searchInput = document.getElementById('search-modal-input') as HTMLInputElement;\n    this.searchResults = document.getElementById('search-modal-results') as HTMLDivElement;\n\n    if (!this.searchModal || !this.searchInput || !this.searchResults) {\n      console.warn('[~] Search modal elements not found');\n      return;\n    }\n\n    // Search trigger button\n    const searchTrigger = document.getElementById('search-trigger');\n    if (searchTrigger) {\n      searchTrigger.addEventListener('click', () => {\n        this.open();\n      });\n    }\n\n    // Tab switcher\n    this.setupTabs();\n\n    // Keyboard shortcut (Cmd/Ctrl + K) to open modal\n    document.addEventListener('keydown', (e) => {\n      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {\n        e.preventDefault();\n        this.open();\n      }\n      // Escape to close\n      if (e.key === 'Escape' && this.searchModal?.classList.contains('active')) {\n        this.close();\n      }\n      // Arrow key navigation\n      if (this.searchModal?.classList.contains('active')) {\n        if (e.key === 'ArrowDown') {\n          e.preventDefault();\n          this.navigateResults(1);\n        } else if (e.key === 'ArrowUp') {\n          e.preventDefault();\n          this.navigateResults(-1);\n        } else if (e.key === 'Enter' && this.selectedIndex >= 0) {\n          e.preventDefault();\n          this.selectResult();\n        }\n      }\n    });\n\n    // Search on input\n    this.searchInput.addEventListener('input', (e) => {\n      const query = (e.target as HTMLInputElement).value;\n      this.selectedIndex = -1;\n      void this.performSearch(query);\n\n      // Update graph if graph tab is active\n      const graphTab = document.querySelector('.search-tab[data-tab=\"graph\"]');\n      if (graphTab?.classList.contains('active')) {\n        void this.renderSearchGraph(query);\n      }\n    });\n\n    // Close on backdrop click\n    this.searchModal.addEventListener('click', (e) => {\n      if (e.target === this.searchModal) {\n        this.close();\n      }\n    });\n  }\n\n  private performSearch(query: string): void {\n    if (!this.searchIndex || !this.searchResults) return;\n\n    if (query.length < 2) {\n      this.searchResults.innerHTML = '';\n      return;\n    }\n\n    const results = this.searchIndex.search(query, {\n      boost: { title: 3, section_title: 2, tags: 2 },\n      fuzzy: 0.2,\n      prefix: true,\n    }).slice(0, 10);\n\n    if (results.length === 0) {\n      this.searchResults.innerHTML = '<div class=\"search-no-results\">No results found</div>';\n      this.searchResults.style.display = 'block';\n      return;\n    }\n\n    // Render results\n    const resultsList = document.createElement('ul');\n    resultsList.className = 'search-results-list';\n\n    results.forEach(result => {\n      const li = document.createElement('li');\n      const link = document.createElement('a');\n      link.href = result.url;\n\n      const sectionInfo = result.section_title\n        ? `<span class=\"search-result-section\">${this.escapeHtml(result.section_title)}</span>`\n        : '';\n\n      link.innerHTML = `\n        <div class=\"search-result-header\">\n          <span class=\"search-result-type\">${result.type}</span>\n          <span class=\"search-result-title\">${this.escapeHtml(result.title)}</span>\n          ${sectionInfo}\n        </div>\n        <div class=\"search-result-snippet\">${this.escapeHtml(result.snippet)}</div>\n      `;\n      li.appendChild(link);\n      resultsList.appendChild(li);\n    });\n\n    this.searchResults.innerHTML = '';\n    this.searchResults.appendChild(resultsList);\n    this.searchResults.style.display = 'block';\n  }\n\n  open(): void {\n    this.searchModal?.classList.add('active');\n    this.searchInput?.focus();\n    void this.ensureIndexLoaded();\n  }\n\n  close(): void {\n    this.searchModal?.classList.remove('active');\n    if (this.searchInput) this.searchInput.value = '';\n    if (this.searchResults) this.searchResults.innerHTML = '';\n    this.selectedIndex = -1;\n\n    // Clean up graph if it was rendered\n    if (this.searchGraphCleanup) {\n      this.searchGraphCleanup();\n      this.searchGraphCleanup = null;\n    }\n\n    // Reset to results tab\n    const tabs = document.querySelectorAll('.search-tab');\n    tabs.forEach((t) => t.classList.remove('active'));\n    const resultsTab = document.querySelector('.search-tab[data-tab=\"results\"]');\n    resultsTab?.classList.add('active');\n\n    const panels = document.querySelectorAll('.search-tab-panel');\n    panels.forEach((p) => p.classList.remove('active'));\n    document.getElementById('search-tab-results')?.classList.add('active');\n  }\n\n  private navigateResults(direction: number): void {\n    const results = this.searchResults?.querySelectorAll('li');\n    if (!results || results.length === 0) return;\n\n    // Remove previous selection\n    if (this.selectedIndex >= 0 && this.selectedIndex < results.length) {\n      results[this.selectedIndex].classList.remove('selected');\n    }\n\n    // Update index\n    this.selectedIndex += direction;\n    if (this.selectedIndex < 0) this.selectedIndex = results.length - 1;\n    if (this.selectedIndex >= results.length) this.selectedIndex = 0;\n\n    // Add new selection\n    results[this.selectedIndex].classList.add('selected');\n    results[this.selectedIndex].scrollIntoView({ block: 'nearest' });\n  }\n\n  private selectResult(): void {\n    const results = this.searchResults?.querySelectorAll('li a');\n    if (!results || this.selectedIndex < 0 || this.selectedIndex >= results.length) return;\n\n    const link = results[this.selectedIndex] as HTMLAnchorElement;\n    window.location.href = link.href;\n  }\n\n  private setupTabs(): void {\n    const tabs = document.querySelectorAll('.search-tab');\n    tabs.forEach((tab) => {\n      tab.addEventListener('click', () => {\n        const tabName = tab.getAttribute('data-tab');\n        if (!tabName) return;\n\n        // Update tab buttons\n        tabs.forEach((t) => t.classList.remove('active'));\n        tab.classList.add('active');\n\n        // Update tab panels\n        const panels = document.querySelectorAll('.search-tab-panel');\n        panels.forEach((p) => p.classList.remove('active'));\n\n        const targetPanel = document.getElementById(`search-tab-${tabName}`);\n        if (targetPanel) {\n          targetPanel.classList.add('active');\n\n          // Render filtered graph when switching to graph tab\n          if (tabName === 'graph') {\n            const query = this.searchInput?.value || '';\n            void this.renderSearchGraph(query);\n          }\n        }\n      });\n    });\n  }\n\n  private async renderSearchGraph(query: string): Promise<void> {\n    const container = document.getElementById('search-graph-container');\n    if (!container) return;\n\n    const ready = await this.ensureIndexLoaded();\n    if (!ready) return;\n\n    // Clean up previous graph\n    if (this.searchGraphCleanup) {\n      this.searchGraphCleanup();\n      this.searchGraphCleanup = null;\n    }\n\n    try {\n      // Import graph rendering\n      const { renderGraph } = await import('./graph-visual');\n\n      // Load graph data\n      const response = await fetch(resolveWithBase('graph.json'));\n      if (!response.ok) return;\n\n      const graphData = await response.json();\n\n      // Filter graph based on search query\n      let filteredGraphData = graphData;\n      if (query.length >= 2 && this.searchIndex) {\n        // Get matching document IDs from search\n        const searchResults = this.searchIndex.search(query, {\n          boost: { title: 3, section_title: 2, tags: 2 },\n          fuzzy: 0.2,\n          prefix: true,\n        });\n\n        // Extract matching page slugs from search results\n        const matchingSlugs = new Set<string>();\n        searchResults.forEach((result) => {\n          const doc = this.documents[parseInt(result.id)];\n          if (doc) {\n            // Extract slug from URL (/page.html or /page.html#section)\n            const urlMatch = doc.url.match(/\\/([^/]+)\\.html/);\n            if (urlMatch) {\n              matchingSlugs.add(urlMatch[1]);\n            }\n          }\n        });\n\n        // Filter nodes and edges to show only matching pages and their connections\n        if (matchingSlugs.size > 0) {\n          const nodes = graphData.nodes.filter((n: any) => matchingSlugs.has(n.id));\n          const nodeIds = new Set(nodes.map((n: any) => n.id));\n          const edges = graphData.edges.filter(\n            (e: any) => nodeIds.has(e.source) && nodeIds.has(e.target),\n          );\n\n          filteredGraphData = { nodes, edges };\n          console.log(\n            `[+] Filtered graph to ${nodes.length} matching nodes from search query: \"${query}\"`,\n          );\n        }\n      }\n\n      // Get current page slug for highlighting\n      const path = window.location.pathname;\n      const match = path.match(/\\/([^/]+)\\.html$/);\n      const currentSlug = match ? match[1] : '';\n\n      // Render filtered graph\n      const config = {\n        drag: true,\n        zoom: true,\n        depth: -1,\n        scale: 1.0,\n        repelForce: 0.5,\n        centerForce: 0.3,\n        linkDistance: 40,\n        fontSize: 0.7,\n        opacityScale: 1,\n        focusOnHover: true,\n      };\n\n      this.searchGraphCleanup = await renderGraph(\n        container,\n        currentSlug,\n        filteredGraphData,\n        config,\n      );\n      console.log('[+] Graph rendered in search modal');\n    } catch (e) {\n      console.error('[!] Failed to render graph in search modal:', e);\n    }\n  }\n\n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  private async ensureIndexLoaded(): Promise<boolean> {\n    if (this.indexReady) return true;\n    if (!this.indexLoadPromise) {\n      this.indexLoadPromise = (async () => {\n        try {\n          const response = await fetch(resolveWithBase('index.json'));\n          if (!response.ok) {\n            console.warn('[~] Search index not available');\n            return;\n          }\n          this.documents = await response.json();\n\n          this.searchIndex = new MiniSearch({\n            fields: ['title', 'section_title', 'content', 'tags'],\n            storeFields: ['url', 'title', 'section_title', 'snippet', 'type'],\n          });\n\n          this.searchIndex.addAll(this.documents.map((doc, idx) => ({\n            ...doc,\n            id: String(idx),\n          })));\n\n          this.indexReady = true;\n          console.log('[+] Search ready - press Cmd/Ctrl+K to search');\n        } catch (e) {\n          console.warn('[~] Failed to load search index:', e);\n        }\n      })();\n    }\n\n    await this.indexLoadPromise;\n    return this.indexReady;\n  }\n}\n\n// Singleton instance\nlet searchManager: SearchManager | null = null;\n\nexport async function initSearch(): Promise<void> {\n  if (!searchManager) {\n    searchManager = new SearchManager();\n  }\n  await searchManager.init();\n}\n\nexport function openSearchModal(): void {\n  if (!searchManager) {\n    searchManager = new SearchManager();\n    searchManager.init().catch(console.error);\n  }\n  searchManager.open();\n}\n\nexport type { SearchDocument };\n"],"names":["node","child","key","document","chunk","promise","conditions","options","results","query","boosts","data"],"mappings":"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","x_google_ignoreList":[0]}